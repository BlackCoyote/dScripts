########################
#
# Version script and script tracker ping
#
######################
towns_version:
  type: version
  name: dTowns
  id: 110
  description: dTowns
  version: 7
towns_script_tracker:
  type: world
  debug: false
  events:
    on system time hourly:
    - webget "http://stats.denizenscript.com/tracker?script=110&version=<s@towns_version.yaml_key[version]>&players=<server.list_online_players.size>&towns=<yaml[towns_lookup_table].list_keys[towns].size||0>"
########################
#
# File handler
#
######################
towns_file_handler:
  type: world
  debug: false
  events:
    on server prestart:
    - run towns_reload_config
    - wait 1t
    - run towns_load_lookup_table
    - run towns_update_townlist
    - wait 1t
    - run towns_fix_cuboids
    on reload scripts:
    - run towns_reload_config
    on player joins:
    - run towns_checkload_town def:<proc[towns_get_town].context[<pl>]>
    on player quits:
    - run towns_checkunload_town def:<proc[towns_get_town].context[<pl>]>
    on shutdown:
    - foreach <server.list_online_players>:
      - run towns_checkunload_town def:<proc[towns_get_town].context[<def[value]>]>
    on system time minutely:
    - if <context.minute.mod[10]> != 0 queue clear
    - run towns_save
towns_reload_config:
  type: task
  debug: false
  speed: 0
  script:
  - if <server.has_file[/towns/config/config.yml]> {
    - yaml load:/towns/config/config.yml id:towns_config
    } else {
    - yaml create id:towns_config
    - yaml id:towns_config set towns.creation.creation_cost:500
    - yaml id:towns_config set towns.claiming.claiming_cost:100
    - yaml id:towns_config set towns.claiming.outpost_claiming_cost:1000
    - yaml id:towns_config set towns.claiming.chunks_per_player:8
    - yaml id:towns_config set towns.claiming.outposts_per_player:1
    - yaml id:towns_config set towns.use_dynmap:false
    - yaml id:towns_config set towns.allow_dynmap_shenanigans:false
    - yaml id:towns_config set towns.language:english
    - yaml savefile:/towns/config/config.yml id:towns_config
    }
towns_load_lookup_table:
  type: task
  debug: false
  speed: 0
  script:
  - if <server.has_file[/towns/lookup_table/lookup_table.yml]> {
    - yaml load:/towns/lookup_table/lookup_table.yml id:towns_lookup_table
    } else {
    - yaml create id:towns_lookup_table
    - yaml savefile:/lookup_table/lookup_table/config.yml id:towns_lookup_table
    }
towns_checkload_town:
  type: task
  debug: false
  speed: 0
  definitions: town
  script:
  - if <def[town]||null> == null queue clear
  - if <yaml.list> !contains towns_town_<def[town]> {
    - if <server.has_file[/towns/town_saves/<def[town]>.yml]> {
      - yaml load:towns/town_saves/<def[town]>.yml id:towns_town_<def[town]>
      } else {
      - yaml create id:id:towns_town_<def[town]>
      }
    }
towns_checkunload_town:
  type: task
  debug: false
  speed: 0
  definitions: town
  script:
  - if <def[town]||null> == null queue clear
  - if <proc[towns_get_members].context[<def[town]>].filter[is_online].size||0> > 0 queue clear
  - if <yaml.list> contains towns_town_<def[town]> {
    - yaml savefile:towns/town_saves/<def[town]>.yml id:towns_town_<def[town]>
    - yaml unload id:towns_town_<def[town]>
    }
towns_save:
  type: task
  debug: false
  speed: 0
  script:
  - announce to_ops "<&7>Saving towns data..."
  - if <yaml.list> contains towns_lookup_table {
    - yaml savefile:/towns/lookup_table/lookup_table.yml id:towns_lookup_table
    }
  - foreach <yaml.list.filter[starts_with[towns_town_]]>:
    - define town <def[value].after[towns_town_].to_lowercase>
    - if <proc[towns_get_members].context[<def[town]>].filter[is_online].size||0> > 0 {
      - yaml savefile:towns/town_saves/<def[town]>.yml id:towns_town_<def[town]>
      } else {
      - run towns_checkunload_town def:<def[town]>
      }
  - announce to_ops "<&7>Towns data saved."
towns_fix_cuboids:
  type: task
  debug: false
  speed: 0
  script:
  - foreach <yaml[towns_lookup_table].list_keys[towns]>:
    - define town <def[value]>
    - foreach <proc[towns_get_chunks].context[<def[town]>]>:
      - define chunk <proc[towns_format_chunk_to_normal].context[<def[value]>]>
      - define chunkname <def[chunk]>
      - note <def[chunk].cuboid> as:towns/<def[town]>/<def[chunkname]>
########################
#
# command handler
#
######################
towns_command_handler:
  type: command
  debug: false
  name: towns
  description: Towns
  usage: /t
  aliases: 
  - tt
  - t
  - town
  - towns
  - towny
  tab complete: 
  - determine li@
  script:
    - choose <context.args.get[1]||null>:
      - case help:
        - inject locally path:help
      - case create:
        - inject locally path:create
      - case disband:
        - inject locally path:disband
      - case invite:
        - inject locally path:invite
      - case accept:
        - inject locally path:accept
      - case leave:
        - inject locally path:leave
      - case kick:
        - inject locally path:kick
      - case info:
        - inject locally path:info
      - case rename:
        - inject locally path:rename
      - case claim:
        - inject locally path:claim
      - case unclaim:
        - inject locally path:unclaim
      - case deposit:
        - inject locally path:deposit
      - case withdraw:
        - inject locally path:withdraw
      - case toggle:
        - inject locally path:toggle
      - case rank:
        - inject locally path:rank
      - case setspawn:
        - inject locally path:setspawn
      - case map:
        - inject locally path:map
      - case outpost:
        - inject locally path:outpost
      - case list:
        - inject locally path:list
      - case outline:
        - inject locally path:outline
      - case teleport:
        - inject locally path:teleport
      - case center:
        - inject locally path:center
      - default:
        - inject locally path:help
  help:
    - define c <script.yaml_key[usage]>
    - narrate "%c% help <&0>-<&7> <parse:<proc[towns_get_translation].context[command-help-info]>>" format:towns_format1
    - narrate "%c% info (player)<&0>-<&7> <parse:<proc[towns_get_translation].context[command-info-info]>>" format:towns_format1
    - narrate "%c% list<&0>-<&7> <parse:<proc[towns_get_translation].context[command-list-info]>>" format:towns_format1
    - narrate "%c% create (name) <&0>-<&7> <parse:<proc[towns_get_translation].context[command-create-info]>>" format:towns_format1
    - narrate "%c% teleport <&0>-<&7> <parse:<proc[towns_get_translation].context[command-teleport-info]>>" format:towns_format1
    - narrate "%c% setspawn (town/outpost) <&0>-<&7> <parse:<proc[towns_get_translation].context[command-setspawn-info]>>" format:towns_format1
    - narrate "%c% center <&0>-<&7> <parse:<proc[towns_get_translation].context[command-center-info]>>" format:towns_format1
    - narrate "%c% teleport <&0>-<&7> <parse:<proc[towns_get_translation].context[command-teleport-info]>>" format:towns_format1
    - narrate "%c% invite (player) <&0>-<&7> <parse:<proc[towns_get_translation].context[command-invite-info]>>" format:towns_format1
    - narrate "%c% accept <&0>-<&7> <parse:<proc[towns_get_translation].context[command-accept-info]>>" format:towns_format1
    - narrate "%c% leave <&0>-<&7> <parse:<proc[towns_get_translation].context[command-leave-info]>>" format:towns_format1
    - narrate "%c% kick (player) <&0>-<&7> <parse:<proc[towns_get_translation].context[command-kick-info]>>" format:towns_format1
    - narrate "%c% deposit (<&ns>) <&0>-<&7> <parse:<proc[towns_get_translation].context[command-deposit-info]>>" format:towns_format1
    - narrate "%c% withdraw (<&ns>) <&0>-<&7> <parse:<proc[towns_get_translation].context[command-withdraw-info]>>" format:towns_format1
    - narrate "%c% toggle (pistons/pvp/titlescreen) <&0>-<&7> <parse:<proc[towns_get_translation].context[command-toggle-info]>>" format:towns_format1
    - narrate "%c% rank (player) (rank) <&0>-<&7> <parse:<proc[towns_get_translation].context[command-rank-info]>>" format:towns_format1
    - narrate "%c% claim <&0>-<&7> <parse:<proc[towns_get_translation].context[command-claim-info]>>" format:towns_format1
    - narrate "%c% outpost <&0>-<&7> <parse:<proc[towns_get_translation].context[command-outpost-info]>>" format:towns_format1
    - narrate "%c% unclaim <&0>-<&7> <parse:<proc[towns_get_translation].context[command-unclaim-info]>>" format:towns_format1
    - narrate "%c% disband <&0>-<&7> <parse:<proc[towns_get_translation].context[command-disband-info]>>" format:towns_format1
    - narrate "%c% rename (name) <&0>-<&7> <parse:<proc[towns_get_translation].context[command-rename-info]>>" format:towns_format1
    - narrate "%c% map <&0>-<&7> <parse:<proc[towns_get_translation].context[command-map-info]>>" format:towns_format1
    - narrate "%c% outline <&0>-<&7> <parse:<proc[towns_get_translation].context[command-outline-info]>>" format:towns_format1
  create:
    - if <proc[towns_get_town]> != null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[already-in-town]>>" format:towns_format1
      - queue clear
      }
    - define cost <yaml[towns_config].read[towns.creation.creation_cost]||100>
    - if <player.money> < <def[cost]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-enough-money-to-create]>>" format:towns_format1
      - queue clear
      }
    - if <player.has_permission[towns.town.create].not||true> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-allowed-create]>>" format:towns_format1
      - queue clear
      }
    - define name <context.raw_args.after[create<&sp>]>
    - if <def[name]> == null || <def[name]> == "" {
      - narrate "<&c><parse:<proc[towns_get_translation].context[no-name-specified]>>" format:towns_format1
      - queue clear
      }
    - take money qty:<def[cost]>
    - run towns_create_town def:<player>|<def[name].escaped>
  disband:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if <proc[towns_get_rank]> != owner {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-owner-of-town]>>" format:towns_format1
      - queue clear
      }
    - run towns_disband_town def:<def[town]>
  invite:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if li@owner|assistant !contains <proc[towns_get_rank]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[insufficient-rank]>>" format:towns_format1
      - queue clear
      }
    - define target <server.match_player[<context.args.get[2]||null>]||null>
    - if <def[target]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[invalid-player-specified]>>" format:towns_format1
      - queue clear
      }
    - define playername <def[target].name||null>
    - if <proc[towns_get_town].context[<def[target]>]> != null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[target-player-already-in-town]>>" format:towns_format1
      - queue clear
      }
    - flag <def[target]> towns.invited_to:<def[town]> duration:1m
    - narrate "<parse:<proc[towns_get_translation].context[invited-player]>>" format:towns_format1
    - define playername <player.name||null>
    - define townname <proc[towns_get_name].context[<def[town]>]||unnamed>
    - define command <script.yaml_key[usage]>
    - narrate "<parse:<proc[towns_get_translation].context[invitation-recieved]>>" targets:<def[target]> format:towns_format1
  accept:
    - if <player.has_flag[towns.invited_to].not> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[no-invitations]>>" format:towns_format1
      - queue clear
      }
    - if <proc[towns_get_town]> != null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[already-in-town]>>" format:towns_format1
      - queue clear
      }
    - define town <player.flag[towns.invited_to]||null>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[invalid-invitation]>>" format:towns_format1
      - queue clear
      }
    - run towns_add_player def:<def[town]>|<player>
  leave:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if li@owner contains <proc[towns_get_rank]> {
      - define command <script.yaml_key[usage]>
      - narrate "<&c><parse:<proc[towns_get_translation].context[owner-cant-leave]>>" format:towns_format1
      - queue clear
      }
    - run towns_remove_player def:<def[town]>|<player>
  kick:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if li@owner|assistant !contains <proc[towns_get_rank]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[insufficient-rank]>>" format:towns_format1
      - queue clear
      }
    - define target <server.match_player[<context.args.get[2]>]||null>
    - if <def[target]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[invalid-player-specified]>>" format:towns_format1
      - queue clear
      }
    - define playername <def[target].name>
    - if <proc[towns_get_town].context[<def[target]>]> != <def[town]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[player-not-in-your-town]>>" format:towns_format1
      - queue clear
      }
    - run towns_kick_player def:<def[town]>|<def[target]>
  rename:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if <proc[towns_get_rank]> != owner {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-owner-of-town]>>" format:towns_format1
      - queue clear
      }
    - define name <context.raw_args.after[rename<&sp>]>
    - if <def[name]> == null || <def[name]> == "" {
      - narrate "<&c><parse:<proc[towns_get_translation].context[must-specify-townname]>>" format:towns_format1
      - queue clear
      }
    - run towns_rename_town def:<def[town]>|<def[name].escaped>
  claim:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if li@owner|assistant !contains <proc[towns_get_rank]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[insufficient-rank]>>" format:towns_format1
      - queue clear
      }
    - if <proc[towns_get_bank_money].context[<def[town]>]> < <yaml[towns_config].read[towns.claiming.claiming_cost]||100> {
      - define required <yaml[towns_config].read[towns.claiming.claiming_cost]||100>
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-enough-money]>>" format:towns_format1
      - queue clear
      }
    - define currentchunks <proc[towns_get_chunks].context[<def[town]>]>
    - if <def[currentchunks].size> >= <proc[towns_get_max_chunks].context[<def[town]>]> {
      - define max <proc[towns_get_max_chunks].context[<def[town]>].as_int>
      - narrate "<&c><parse:<proc[towns_get_translation].context[max-chunks]>>" format:towns_format1
      - queue clear
      }
    - define chunk <player.location.chunk>
    - if <def[currentchunks]> contains <proc[towns_format_chunk_to_save].context[<def[chunk]>]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[chunk-already-claimed-by-you]>>" format:towns_format1
      - queue clear
      }
    - define viablechunks li@<proc[towns_format_chunk_to_save].context[<def[chunk].add[1,0]>]>|<proc[towns_format_chunk_to_save].context[<def[chunk].add[-1,0]>]>|<proc[towns_format_chunk_to_save].context[<def[chunk].add[0,1]>]>|<proc[towns_format_chunk_to_save].context[<def[chunk].add[0,-1]>]>
    - if <def[currentchunks].contains_any[<def[viablechunks]>].not> && <def[currentchunks].size> > 0 {
      - narrate "<&c><parse:<proc[towns_get_translation].context[chunk-not-attached]>>" format:towns_format1
      - queue clear
      }
    - if <server.list_notables[cuboids].filter[intersects[<def[chunk].cuboid>]].size> > 0 || <def[chunk].cuboid.regions.size||0> > 0 {
      - narrate "<&c><parse:<proc[towns_get_translation].context[chunk-already-claimed-by-other]>>" format:towns_format1
      - queue clear
      }
    - yaml id:towns_town_<def[town]> set town.bank.money:-:<yaml[towns_config].read[towns.claiming.claiming_cost]||100>
    - run towns_claim_chunk def:<def[town]>|<def[chunk]>|normal|<player>
  outpost:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if li@owner|assistant !contains <proc[towns_get_rank]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[insufficient-rank]>>" format:towns_format1
      - queue clear
      }
    - if <proc[towns_get_bank_money].context[<def[town]>]> < <yaml[towns_config].read[towns.claiming.outpost_claiming_cost]||1000> {
      - define required <yaml[towns_config].read[towns.claiming.outpost_claiming_cost]||1000>
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-enough-money]>>" format:towns_format1
      - queue clear
      }
    - define currentchunks <proc[towns_get_chunks].context[<def[town]>]>
    - if <def[currentchunks].size> >= <proc[towns_get_max_chunks].context[<def[town]>]> {
      - define max <proc[towns_get_max_chunks].context[<def[town]>].as_int>
      - narrate "<&c><parse:<proc[towns_get_translation].context[max-chunks]>>" format:towns_format1
      - queue clear
      }
    - if <proc[towns_get_max_outposts].context[<def[town]>]> <= <proc[towns_get_outposts].context[<def[town]>].size> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[max-outposts]>>" format:towns_format1
      - queue clear
      }
    - define chunk <player.location.chunk>
    - if <def[currentchunks]> contains <proc[towns_format_chunk_to_save].context[<def[chunk]>]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[chunk-already-claimed-by-you]>>" format:towns_format1
      - queue clear
      }
    - define viablechunks li@<proc[towns_format_chunk_to_save].context[<def[chunk].add[1,0]>]>|<proc[towns_format_chunk_to_save].context[<def[chunk].add[-1,0]>]>|<proc[towns_format_chunk_to_save].context[<def[chunk].add[0,1]>]>|<proc[towns_format_chunk_to_save].context[<def[chunk].add[0,-1]>]>
    # - if <def[currentchunks].contains_any[<def[viablechunks]>]> {
      # - narrate "<&c>You can't claim an outpost this close to your town." format:towns_format1
      # - queue clear
      # }
    - if <server.list_notables[cuboids].filter[intersects[<def[chunk].cuboid>]].size> > 0 || <def[chunk].cuboid.regions.size||0> > 0 {
      - narrate "<&c><parse:<proc[towns_get_translation].context[chunk-already-claimed-by-other]>>" format:towns_format1
      - queue clear
      }
    - yaml id:towns_town_<def[town]> set town.bank.money:-:<yaml[towns_config].read[towns.claiming.outpost_claiming_cost]||1000>
    - run towns_claim_chunk def:<def[town]>|<def[chunk]>|outpost|<player>
  unclaim:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if li@owner|assistant !contains <proc[towns_get_rank]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[insufficient-rank]>>" format:towns_format1
      - queue clear
      }
    - define currentchunks <proc[towns_get_chunks].context[<def[town]>]>
    - if <def[currentchunks].size> <= 0 {
      - narrate "<&c><parse:<proc[towns_get_translation].context[has-no-chunks]>>" format:towns_format1
      - queue clear
      }
    - define chunk <player.location.chunk>
    - if <def[currentchunks]> !contains <proc[towns_format_chunk_to_save].context[<def[chunk]>]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[chunk-not-yours]>>" format:towns_format1
      - queue clear
      }
    - define is_essential <proc[towns_chunk_is_essential].context[<def[chunk]>]>
    - if <def[is_essential]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[chunk-is-essential]>>" format:towns_format1
      - queue clear
      }
    - run towns_unclaim_chunk def:<def[town]>|<def[chunk]>|<player>
  deposit:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - define amount <context.args.get[2].as_int||null>
    - if <def[amount]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[must-specify-valid-number]>>" format:towns_format1
      - queue clear
      }
    - if <player.money> < <def[amount]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-enough-money-player]>>" format:towns_format1
      - queue clear
      }
    - take money qty:<def[amount]>
    - run towns_give_money def:<def[town]>|<def[amount]>|<player>
  withdraw:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if li@owner !contains <proc[towns_get_rank]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[insufficient-rank]>>" format:towns_format1
      - queue clear
      }
    - define amount <context.args.get[2].as_int||null>
    - if <def[amount]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[must-specify-valid-number]>>" format:towns_format1
      - queue clear
      }
    - if <proc[towns_get_bank_money].context[<def[town]>]> < <def[amount]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-enough-money]>>" format:towns_format1
      - queue clear
      }
    - give money qty:<def[amount]>
    - yaml id:towns_town_<def[town]> set town.bank.money:-:<def[amount]>
    - define number <def[amount].format_number>
    - narrate format:towns_format1 "<proc[towns_get_translation].context[withdrew-money]>"
  toggle:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if li@owner|assistant !contains <proc[towns_get_rank]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[insufficient-rank]>>" format:towns_format1
      - queue clear
      }
    - define rule <context.args.get[2]||null>
    - define rules li@Pistons|PVP|Titlescreen
    - if <def[rules]> !contains <def[rule]> {
      - define rulelist <def[rules].formatted>
      - narrate "<&c><parse:<proc[towns_get_translation].context[invalid-rule]>>" format:towns_format1
      - queue clear
      }
    - define state <proc[towns_get_rule].context[<def[town]>|<def[rule]>]||false>
    - run towns_set_rule def:<def[town]>|<def[rule]>|<def[state].not||true>|<player>
  rank:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if li@owner !contains <proc[towns_get_rank]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[insufficient-rank]>>" format:towns_format1
      - queue clear
      }
    - define target <server.match_offline_player[<context.args.get[2]||null>]||null>
    - if <def[target]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[inexistant-player-specified]>>" format:towns_format1
      - queue clear
      }
    - if <proc[towns_get_town].context[<def[target]>]> != <def[town]> {
      - define playername <def[target].name>
      - narrate "<&c><parse:<proc[towns_get_translation].context[player-not-in-your-town]>>" format:towns_format1
      - queue clear
      }
    - define rank <context.args.get[3]||null>
    - if li@member|assistant !contains <def[rank]> {
      - define ranklist Assistant, Member.
      - narrate "<&c><parse:<proc[towns_get_translation].context[invalid-rank]>>" format:towns_format1
      - queue clear
      }
    - run towns_set_rank def:<def[town]>|<def[target]>|<def[rank]>
  outline:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if <player.has_flag[towns.show_outline]> {
      - flag <player> "towns.show_outline:!"
      - narrate "<&c><parse:<proc[towns_get_translation].context[outline-enabled]>>" format:towns_format1
      } else {
      - flag <player> "towns.show_outline:true" duration:5m
      - narrate "<&c><parse:<proc[towns_get_translation].context[outline-disabled]>>" format:towns_format1
      }
  setspawn:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if li@owner|assistant !contains <proc[towns_get_rank]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[insufficient-rank]>>" format:towns_format1
      - queue clear
      }
    - if <proc[towns_get_town_from_chunk].context[<player.location.chunk>]> != <def[town]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[invalid-spawnpoint-location]>>" format:towns_format1
      - queue clear
      }
    - define type <context.args.get[2]||town>
    - if li@town|outpost !contains <def[type]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[invalid-type-for-spawnpoint]>>" format:towns_format1
      - queue clear
      }
    - choose <def[type]>:
      - case town:
        - yaml id:towns_town_<def[town]> set town.spawnpoint:<player.location.escaped>
        - narrate "<parse:<proc[towns_get_translation].context[spawnpoint-updated]>>" format:towns_format1
        - run towns_update_dynmap_spawnpoint def:<def[town]>
      - case outpost:
        - if <proc[towns_get_chunk_type].context[<player.location.chunk>]> != outpost {
          - narrate "<&c><parse:<proc[towns_get_translation].context[not-outpost-chunk]>>" format:towns_format1
          - queue clear
          }
        - yaml id:towns_town_<def[town]> set town.chunks.<proc[towns_format_chunk_to_save].context[<player.location.chunk>]>.spawnpoint:<player.location.escaped>
        - narrate "<parse:<proc[towns_get_translation].context[spawnpoint-updated]>>" format:towns_format1
  teleport:
    - if <player.is_op> {
      - if <context.args.get[2]||null> != null {
        - define player <server.match_offline_player[<context.args.get[2]||null>]||null>
        - if <def[player]> == null {
          - narrate "<&c><parse:<proc[towns_get_translation].context[invalid-player-specified]>>" format:towns_format1
          - queue clear
          } else {
          - define town <proc[towns_get_town].context[<def[player]>]>
          - if <def[town]> == null {
            - narrate "<&c><parse:<proc[towns_get_translation].context[player-not-in-town]>>" format:towns_format1
            - queue clear
            }
          }
        } else {
        - define town <proc[towns_get_town]>
        - if <def[town]> == null {
          - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
          - queue clear
          }
        }
      } else {
      - define town <proc[towns_get_town]>
      - if <def[town]> == null {
        - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
        - queue clear
        }
      }
    - flag <player> towns.town_inv:<def[town]>
    - inventory open d:in@towns_teleport_menu
  center:
    - define town <proc[towns_get_town]>
    - if <def[town]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
      - queue clear
      }
    - if li@owner|assistant !contains <proc[towns_get_rank]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[insufficient-rank]>>" format:towns_format1
      - queue clear
      }
    - define chunk <player.location.chunk>
    - if <proc[towns_get_town_from_chunk].context[<def[chunk]>]> != <def[town]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[invalid-center-chunk]>>" format:towns_format1
      - queue clear
      }
    - define type <proc[towns_get_chunk_type].context[<def[chunk]>]>
    - if li@center|outpost contains <def[type]> {
      - narrate "<&c><parse:<proc[towns_get_translation].context[invalid-type-for-center]>>" format:towns_format1
      - queue clear
      }
    - define oldchunkname <yaml[towns_town_<def[town]>].read[town.center]||null>
    - define oldchunk <proc[towns_format_chunk_to_normal].context[<def[oldchunkname]>]>
    - define chunkname <proc[towns_format_chunk_to_save].context[<def[chunk]>]>
    - yaml id:towns_town_<def[town]> set town.chunks.<def[chunkname]>.type:center
    - yaml id:towns_town_<def[town]> set town.chunks.<def[oldchunkname]>.type:normal
    - yaml id:towns_town_<def[town]> set town.center:<def[chunkname]>
    - run towns_update_dynmap_chunk def:<def[chunk]>
    - run towns_update_dynmap_chunk def:<def[oldchunk]>
    - narrate "Your town center has been updated." format:towns_format1
  info:
    - if <context.args.get[2]||null> != null {
      - define target <server.match_offline_player[<context.args.get[2]||null>]||null>
      } else {
      - define target <player>
      }
    - if <def[target]> == null {
      - narrate "<&c><parse:<proc[towns_get_translation].context[inexistant-player-specified]>>" format:towns_format1
      - queue clear
      }
    - define town <proc[towns_get_town].context[<def[target]>]>
    - if <def[town]> == null {
      - if <def[target]> == <player> {
        - narrate "<&c><parse:<proc[towns_get_translation].context[not-in-town]>>" format:towns_format1
        } else {
        - narrate "<&c><parse:<proc[towns_get_translation].context[player-not-in-town]>>" format:towns_format1
        }
      - queue clear
      }
    - run towns_show_info def:<def[town]>
  map:
    - run towns_draw_map_book
  list:
    - run towns_show_townlist
########################
#
# executable tasks
#
######################
towns_create_town:
  type: task
  debug: false
  speed: 0
  definitions: player
  script:
    - if <def[player]||null> == null {
      - define player <player>
      }
    - define ID <util.random.uuid>
    - while <server.list_files[/towns/town_saves].contains[<def[id]>.yml]||false>:
      - define ID <util.random.uuid>
    - yaml id:towns_lookup_table set players.<player.uuid>.town:<def[id]>
    - yaml create id:towns_town_<def[id]>
    - yaml set id:towns_town_<def[id]> town.members.<player.uuid>.rank:owner
    - yaml set id:towns_town_<def[id]> town.name:<def[2]||unnamed>
    - yaml savefile:/towns/town_saves/<def[id]>.yml id:towns_town_<def[id]>
    - define playername <player.name>
    - define townname <def[2].unescaped||unnamed>
    - announce "<parse:<proc[towns_get_translation].context[town-created]>>" format:towns_format1
    - run towns_update_town_info def:<def[id]>
towns_disband_town:
  type: task
  debug: false
  speed: 0
  definitions: town
  script:
    - if <def[town]||null> == null queue clear
    - define members <proc[towns_get_members].context[<def[town]>]>
    - define name <proc[towns_get_name].context[<def[town]>]>
    - foreach <def[members]>:
      - yaml set id:towns_lookup_table players.<def[value].uuid>.town:!
    - foreach <server.list_notables[cuboids].filter[contains[towns/<def[town]>]]>:
      - define chunk <def[value].center.chunk>
      - note remove as:<def[value].notable_name>
      - yaml id:towns_lookup_table set chunks.<def[chunk].world.name>.<def[chunk].x>.<def[chunk].z>:!
    - define chunklist <proc[towns_get_chunks].context[<def[town]>].parse[replace[/].with[,].as_chunk]>
    - if <yaml.list> contains towns_town_<def[town]> yaml unload id:towns_town_<def[town]>
    - if <server.list_files[/towns/town_saves]> contains "<def[town]>.yml" adjust server "delete_file:/towns/town_saves/<def[town]>.yml"
    - define townname <proc[towns_get_name].context[<def[town]>]>
    - announce "<parse:<proc[towns_get_translation].context[town-disbanded]>>" format:towns_format1
    - foreach <def[chunklist]>:
      - run towns_update_dynmap_chunk def:<def[value]>
    - run towns_update_townlist
towns_add_player:
  type: task
  debug: false
  speed: 0
  definitions: town|player
  script:
    - if <def[player]||null> == null queue clear
    - if <def[town]||null> == null queue clear
    - define members <proc[towns_get_members].context[<def[town]>]>
    - yaml id:towns_town_<def[town]> set town.members.<def[player].uuid>.rank:member
    - yaml id:towns_lookup_table set players.<def[player].uuid>.town:<def[town]>
    - define playername <def[player].name>
    - define townname <proc[towns_get_name].context[<def[town]>]>
    - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[player-joined-town]>>" targets:<def[members]>
    - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[player-joined-town-personal]>>" targets:<def[player]>
    - run towns_update_town_info def:<def[town]>
towns_remove_player:
  type: task
  debug: false
  speed: 0
  definitions: town|player
  script:
    - if <def[player]||null> == null queue clear
    - if <def[town]||null> == null queue clear
    - define members <proc[towns_get_members].context[<def[town]>].exclude[<def[player]>]>
    - yaml id:towns_town_<def[town]> set town.members.<def[player].uuid>:!
    - yaml id:towns_lookup_table set players.<def[player].uuid>.town:!
    - define playername <def[player].name>
    - define townname <proc[towns_get_name].context[<def[town]>]>
    - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[player-left-town]>>" targets:<def[members]>
    - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[player-left-town-personal]>>" targets:<def[player]>
    - run towns_update_town_info def:<def[town]>
towns_kick_player:
  type: task
  debug: false
  speed: 0
  definitions: town|player
  script:
    - if <def[player]||null> == null queue clear
    - if <def[town]||null> == null queue clear
    - define members <proc[towns_get_members].context[<def[town]>].exclude[<def[player]>]>
    - yaml id:towns_town_<def[town]> set town.members.<def[player].uuid>:!
    - yaml id:towns_lookup_table set players.<def[player].uuid>.town:!
    - define playername <def[player].name>
    - define townname <proc[towns_get_name].context[<def[town]>]>
    - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[player-kicked]>>" targets:<def[members]>
    - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[player-kicked-personal]>>" targets:<def[player]>
    - run towns_update_town_info def:<def[town]>
towns_show_info:
  type: task
  debug: false
  speed: 0
  definitions: town
  script:
    - if <def[town]||null> == null queue clear
    - narrate format:towns_format1 "<&0>============================================="
    - narrate format:towns_format1 "<&6>Town<&co> <&e><proc[towns_get_name].context[<def[town]>]>"
    - narrate format:towns_format1 "<&6>Money<&co> <&e>$<proc[towns_get_bank_money].context[<def[town]>].format_number>"
    - narrate format:towns_format1 "<&6>Size<&co> <&e><proc[towns_get_chunks].context[<def[town]>].size>/<proc[towns_get_max_chunks].context[<def[town]>]>"
    - narrate format:towns_format1 "<&6>outposts<&co> <&e><proc[towns_get_outposts].context[<def[town]>].size>/<proc[towns_get_max_outposts].context[<def[town]>]>"
    - narrate format:towns_format1 "<&6>owners<&co> <&e><proc[towns_get_members_by_rank].context[<def[town]>|owner].formatted>"
    - narrate format:towns_format1 "<&6>assistants<&co> <&e><proc[towns_get_members_by_rank].context[<def[town]>|assistant].formatted>"
    - narrate format:towns_format1 "<&6>members<&co> <&e><proc[towns_get_members].context[<def[town]>].formatted>"
    - narrate format:towns_format1 "<&0>============================================="
towns_rename_town:
  type: task
  debug: false
  speed: 0
  definitions: town|name
  script:
    - if <def[name]||null> == null queue clear
    - if <def[town]||null> == null queue clear
    - yaml id:towns_town_<def[town]> set town.name:<def[name]>
    - define townname <def[name].unescaped>
    - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[town-renamed]>>" targets:<proc[towns_get_members].context[<def[town]>].filter[is_online]>
    - run towns_update_town_info def:<def[town]>
towns_add_bonus_chunks:
  type: task
  debug: false
  speed: 0
  definitions: town|amount
  script:
    - if <def[town]||null> == null queue clear
    - define amount <def[amount].as_int||1>
    - yaml id:towns_town_<def[town]> set town.bonus_chunks:+:<def[amount]>
    - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[bonus-chunks]>>" targets:<proc[towns_get_members].context[<def[town]>].filter[is_online]>
towns_add_bonus_outposts:
  type: task
  debug: false
  speed: 0
  definitions: town|amount
  script:
    - if <def[town]||null> == null queue clear
    - define amount <def[amount].as_int||1>
    - yaml id:towns_town_<def[town]> set town.bonus_outposts:+:<def[amount]>
    - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[bonus-outpost]>>" targets:<proc[towns_get_members].context[<def[town]>].filter[is_online]>
towns_give_money:
  type: task
  debug: false
  speed: 0
  definitions: town|amount|player
  script:
    - if <def[town]||null> == null queue clear
    - if <def[amount].as_int||null> == null queue clear
    - yaml id:towns_town_<def[town]> set town.bank.money:+:<def[amount]>
    - define members <proc[towns_get_members].context[<def[town]>].filter[is_online]>
    - define amount <def[amount].format_number>
    - if <def[player].is_player||false> {
      - define playername <def[player].name>
      - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[deposit-money]>>" targets:<def[members]>
      } else {
      - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[bonus-money]>>" targets:<def[members]>
      }
towns_claim_chunk:
  type: task
  debug: false
  speed: 0
  definitions: town|chunk|type|player
  script:
    - if <def[town]||null> == null queue clear
    - if <def[chunk]> == null queue clear
    - if <def[type]> == null define type normal
    - define chunkname <proc[towns_format_chunk_to_save].context[<def[chunk]>]>
    - define group <proc[towns_get_groupuuid_for_new_chunk].context[<def[town]>|<def[chunk]>]>
    - if <proc[towns_get_chunks].context[<def[town]>].size||0> < 1 {
      - yaml id:towns_town_<def[town]> set town.center:<def[chunkname]>
      - yaml id:towns_town_<def[town]> set town.chunks.<def[chunkname]>.type:center
      - run towns_update_dynmap_spawnpoint def:<def[town]>
      } else {
      - yaml id:towns_town_<def[town]> set town.chunks.<def[chunkname]>.type:<def[type]>
      }
    - yaml id:towns_town_<def[town]> set town.chunks.<def[chunkname]>.group:<def[group]>
    - yaml id:towns_town_<def[town]> set town.chunks.<def[chunkname]>.claimed_by:<def[player]||admin>
    - yaml id:towns_lookup_table set chunks.<def[chunk].world.name>.<def[chunk].x>.<def[chunk].z>:<def[town]>
    - note <def[chunk].cuboid> as:towns/<def[town]>/<def[chunkname]>
    - define members <proc[towns_get_members].context[<def[town]>].filter[is_online]>
    - if <def[player].is_player||false> {
      - define playername <def[player].name>
      - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[chunk_claim]>>" targets:<def[members]>
      } else {
      - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[chunk-reward-claim]>>" targets:<def[members]>
      }
    - run towns_update_dynmap_chunk def:<def[chunk]>
towns_unclaim_chunk:
  type: task
  debug: false
  speed: 0
  definitions: town|chunk|player
  script:
    - if <def[town]||null> == null queue clear
    - if <def[chunk]> == null queue clear
    - define chunkname <proc[towns_format_chunk_to_save].context[<def[chunk]>]>
    - yaml id:towns_town_<def[town]> set town.chunks.<def[chunkname]>:!
    - yaml id:towns_lookup_table set chunks.<def[chunk].world.name>.<def[chunk].x>.<def[chunk].z>:!
    - note remove as:towns/<def[town]>/<def[chunkname]>
    - define members <proc[towns_get_members].context[<def[town]>].filter[is_online]>
    - if <def[player].is_player||false> {
      - define playername <def[player].name>
      - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[chunk_unclaim]>>" targets:<def[members]>
      } else {
      - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[chunk-reward-unclaim]>>" targets:<def[members]>
      }
    - run towns_update_dynmap_chunk def:<def[chunk]>
towns_set_rule:
  type: task
  debug: false
  speed: 0
  definitions: town|rule|state|player
  script:
    - if <def[town]||null> == null queue clear
    - if <def[rule]||null> == null queue clear
    - if <def[state]||null> == null queue clear
    - yaml id:towns_town_<def[town]> set town.rule.<def[rule]>:<def[state]>
    - define members <proc[towns_get_members].context[<def[town]>].filter[is_online]>
    - if <def[player]||null> != null {
      - define playername <def[player].name>
      - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[rule-change]>>" targets:<def[members]>
      } else {
      - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[forced-rule-change]>>" targets:<def[members]>
      }
towns_set_rank:
  type: task
  debug: false
  speed: 0
  definitions: town|target|rank
  script:
    - if <def[town]||null> == null queue clear
    - if <def[target]||null> == null queue clear
    - if <def[rank]||null> == null queue clear
    - yaml id:towns_town_<def[town]> set town.members.<def[target].uuid>.rank:<def[rank]>
    - define members <proc[towns_get_members].context[<def[town]>].filter[is_online]>
    - define playername <def[target].name>
    - narrate format:towns_format1 "<parse:<proc[towns_get_translation].context[rank-change]>>" targets:<def[members]>
towns_draw_map_sidebar:
  type: task
  debug: false
  speed: 0
  definitions: player
  script:
    # - async:
      - if <def[player]||null> == null {
        - define player <player||null>
        }
      - if <def[player]||null> == null queue clear
      - define town <proc[towns_get_town].context[<def[player]>]>
      - flag <def[player]> show_towns_map
      - while <def[player].is_online.and[<player.has_flag[show_towns_map]>]>:
        - define chunk <def[player].location.chunk>
        - define map ""
        - repeat 11:
          - define z <def[value].sub[6].as_int>
          - define prefix &<def[value].replace[10].with[a].replace[11].with[b]>
          - define map "<def[map]><def[prefix].parse_color>"
          - define lasticon false
          - repeat 11:
            - define x <def[value].sub[6].as_int>
            - define current <def[chunk].add[<def[X]>,<def[z]>]>
            - define owner <yaml[towns_lookup_table].read[chunks.<def[current].world.name>.<def[current].x>.<def[current].z>]||null>
            - if <def[current]> == <def[chunk]> {
              - define icon <&b>[]
              } else if <def[owner]> == <def[town]> {
              - define icon <&a>[]
              } else if <def[owner]> != null {
              - define icon <&c>[]
              } else {
              - define icon <&8>[]
              }
            - if <def[lasticon]||null> == <def[icon]> define icon []
            - define lasticon <def[icon]>
            - define map "<def[map]><def[icon]>"
          - define map "<def[map]>|"
        - sidebar set "title:<&6>Map" values:<def[map]>
        - wait 1s
towns_draw_map_book:
  type: task
  debug: false
  speed: 0
  definitions: player
  script:
  - async:
    - if <def[player]||null> == null {
      - define player <player||null>
      }
    - if <def[player]||null> == null queue clear
    - define town <proc[towns_get_town].context[<def[player]>]>
    - define chunk <def[player].location.chunk>
    - define map ""
    - repeat 11:
      - define z <def[value].sub[6].as_int>
      - define prefix &<def[value].replace[10].with[a].replace[11].with[b]>
      - define map "<def[map]><def[prefix].parse_color><&sp><&sp><&sp>"
      - define lasticon false
      - repeat 11:
        - define x <def[value].sub[6].as_int>
        - define current <def[chunk].add[<def[X]>,<def[z]>]>
        - define owner <yaml[towns_lookup_table].read[chunks.<def[current].world.name>.<def[current].x>.<def[current].z>]||null>
        - if <def[current]> == <def[chunk]> {
          - define icon <&3>[]
          } else if <def[owner]> == <def[town]> {
          - define icon <&6>[]
          } else if <def[owner]> != null {
          - define icon <&c>[]
          } else {
          - define icon <&8>[]
          }
        - if <def[lasticon]||null> == <def[icon]> define icon []
        - define lasticon <def[icon]>
        - define map "<def[map]><def[icon]>"
      - define map "<def[map]><&nl>"
    - fakeitem "i@written_book[book=author|Wizardsmine|title|Map|pages|<&3><&sp><&sp><&sp><&sp><&sp><&sp><&sp><&sp><&sp><&sp>North<&nl><&nl><def[map]><&nl>You<&co> <&3><&lb><&rb><&nl>Your town<&co> <&6><&lb><&rb><&nl>Other towns<&co> <&c><&lb><&rb><&nl>Wilderness<&co> <&8><&lb><&rb>]" slot:<player.item_in_hand.slot> duration:1t
    - adjust <player> open_book
towns_show_townlist:
  type: task
  debug: false
  speed: 0
  script:
  - define towns ""
  - foreach <yaml[towns_lookup_table].list_keys[towns]||li@>:
    - define town <def[value]>
    - define towns "<def[towns]><&6><yaml[towns_lookup_table].read[towns.<def[town]>.name]||Unknown><&nl><&8>Owner<&co> <&7><yaml[towns_lookup_table].read[towns.<def[town]>.owner].as_player.name||Unknown><&nl><&8>Members<&co> <&7><yaml[towns_lookup_table].read[towns.<def[town]>.membersize]||1><&nl><&nl>"
    - if <def[loop_index].mod[3]> == 0 define towns "<def[towns]><&pipe>"
  - fakeitem "i@written_book[book=author|Wizardsmine|title|Towns|pages|<def[towns].escaped.replace[&pipe].with[<&pipe>]>]" slot:<player.item_in_hand.slot> duration:1t
  - adjust <player> open_book
towns_update_townlist:
  type: task
  debug: false
  speed: 0
  script:
  - yaml id:towns_lookup_table set towns:!
  - yaml id:towns_lookup_table set chunks:!
  - foreach <server.list_files[towns/town_saves/]||li@>:
    - define town "<def[value].before[.yml]>"
    - ~run towns_checkload_town "def:<def[town]>"
    - ~run towns_update_town_info "def:<def[town]>|all"
    - ~run towns_checkunload_town "def:<def[town]>"
towns_update_town_info:
  type: task
  debug: false
  speed: 0
  definitions: town
  script:
    - if <def[town]||null> == null queue clear
    - yaml id:towns_lookup_table set towns.<def[town]>.membersize:<proc[towns_get_members].context[<def[town]>].size||0>
    - yaml id:towns_lookup_table set towns.<def[town]>.name:<proc[towns_get_name].context[<def[town]>]>
    - yaml id:towns_lookup_table set towns.<def[town]>.owner:<proc[towns_get_members_by_rank].context[<def[town]>|owner].get[1]>
    - if <def[2]||null> != all queue clear
    - foreach <proc[towns_get_chunks].context[<def[town]>].parse[replace[/].with[,].as_chunk]||li@>:
      - define chunk <def[value]>
      - yaml id:towns_lookup_table set chunks.<def[chunk].world.name>.<def[chunk].x>.<def[chunk].z>:<def[town]>
########################
#
# event handler
#
######################
towns_event_handler:
  type: world
  debug: false
  events:
    on player breaks block in notable cuboid:
    - inject locally path:check_blockchange
    on player places block in notable cuboid:
    - inject locally path:check_blockchange
    on player right clicks block in notable cuboid:
    - inject locally path:check_blockchange
    on player empties bucket in notable cuboid:
    - inject locally path:check_blockchange
    on player damages entity in notable cuboid:
    - if <context.entity.entity_type> == player queue clear
    - define location <context.entity.location>
    - inject locally path:check_blockchange
    on player damages player in notable cuboid:
    - define location <context.entity.location>
    - define checkfor pvp
    - inject locally path:check_blockchange
    on piston extends:
    - define newblocks <context.blocks.parse[add[<context.relative.sub[<context.location>]>]]>
    - define checkfor pistons
    - foreach <def[newblocks]>:
      - define location <def[value]>
      - inject locally path:check_blockchange
  check_blockchange:
  - if <def[location].exists.not> define location <context.location>
  - if <player.has_permission[towns.override.build]||false> goto finish
  - define town <proc[towns_get_town_from_chunk].context[<def[location].chunk>]>
  - if <def[town]> == null goto finish
  - if <proc[towns_get_town].context[<player||null>]||null> == <def[town]> && <def[checkfor]||null> != pvp {
    - goto finish
    }
  - if <def[checkfor].exists> {
    - if <proc[towns_get_rule].context[<def[town]>|<def[checkfor]>]||false> goto finish
    }
  - narrate "<&c>You are not allowed to do this in the town of <proc[towns_get_name].context[<def[town]>]>" format:towns_format1
  - playeffect <player.location.add[<player.eye_location.direction.vector.mul[2]>]> effect:barrier qty:5 offset:0.5 visibility:50 targets:<player>
  - determine cancelled
  - mark finish
towns_welcome_messages:
  type: world
  debug: false
  events:
    on player enters notable cuboid:
    - inject locally path:handle_titles
    - inject locally path:handle_outline
    on player exits notable cuboid:
    - inject locally path:handle_titles
  handle_titles:
    - define to <proc[towns_get_town_from_chunk].context[<context.to.chunk>]>
    - define from <proc[towns_get_town_from_chunk].context[<context.from.chunk>]>
    - if <def[from]> == null && <def[to]> != null {
      - if <proc[towns_get_rule].context[<def[to]>|titlescreen]> {
        - title "title:<&6>Entering town<&co>" "subtitle:<&e><proc[towns_get_name].context[<def[to]>]>"
        } else {
        - narrate "<&6>Entering town<&co> <&e><proc[towns_get_name].context[<def[to]>]>" format:towns_format1
        }
      } else if <def[from]> != null && <def[to]> == null {
      - if <proc[towns_get_rule].context[<def[from]>|titlescreen]> {
        - title "title:<&6>Leaving town<&co>" "subtitle:<&e><proc[towns_get_name].context[<def[from]>]>"
        } else {
        - narrate "<&6>Leaving town<&co> <&e><proc[towns_get_name].context[<def[from]>]>" format:towns_format1
        }
      }
  handle_outline:
  - if <player.has_flag[towns.outline.cooldown]> queue clear
  - flag <player> "towns.outline.cooldown:true" "duration:2s"
  - async:
    - if <player.has_flag[towns.show_outline]> {
      - playeffect effect:fireworks_spark offset:0.2 qty:10 <context.to.chunk.surface_blocks> visibility:200
      }
########################
#
# translations
#
######################
towns_get_translation:
  type: procedure
  debug: false
  definitions: key
  script:
  - if <def[key]> == null {
    - determine "invalid translation key specified"
    }
  - define language <yaml[towns_config].read[towns.language]||english>
  - if <s@towns_translations.list_keys[translations].contains[<def[language]>].not> {
    - determine "Invalid language specified"
    }
  - define translation <s@towns_translations.yaml_key[translations.<def[language]>.<def[key]>]||null>
  - if <def[translation]> != null {
    - determine <def[translation]>
    } else {
    - determine "<s@towns_translations.yaml_key[translations.english.<def[key]>]||Error processing message>"
    }
towns_translations:
  type: yaml data
  translations:
    english:
      # command help
      command-help-info: Shows this page.
      command-info-info: Shows info about your town.
      command-list-info: Shows a list of existing towns.
      command-create-info: Creates a new town.
      command-teleport-info: Opens the teleporting menu.
      command-setspawn-info: Manages spawnpoints in your town.
      command-center-info: Sets the center chunk of your town.
      command-teleport-info: Lets you teleport to various locations.
      command-invite-info: Invites a player to your town.
      command-accept-info: Accepts your pending invitation.
      command-leave-info: Removes you from your current town.
      command-kick-info: Kicks a player from your town.
      command-deposit-info: Deposits money into your town.
      command-withdraw-info: Withdraws money from your town.
      command-toggle-info: Toggles a certain rule in your town.
      command-rank-info: Change a player's rank.
      command-claim-info: Claims the chunk you're standing in.
      command-outpost-info: Claims an outpost at your location.
      command-unclaim-info: Unclaims the chunk you're standing in.
      command-disband-info: Disbands your town.
      command-rename-info: Changes the name of your town.
      command-map-info: Shows a map of your current area.
      command-outline-info: Shows the outlines of a town chunk.
      # command response
      already-in-town: You are already in a town!
      not-enough-money-to-create: You don't have enough money to create a town. You need $<def[cost]>.
      not-allowed-create: You are not allowed to create a town.
      no-name-specified: You must specify a name for your town!
      not-in-town: You are not in a town!
      player-not-in-town: This player is not in a town!
      not-owner-of-town: You are not the owner of this town.
      insufficient-rank: You do not have the right rank to do this.
      invalid-player-specified: This player is not online!
      inexistant-player-specified: This player does not exist!
      target-player-already-in-town: <def[playername]> is already in a town!
      invited-player: You've invited <def[playername]> to your town.
      invitation-recieved: <def[playername]> has invited you to the town of <def[townname]>!<&nl>Type '<def[command]> accept' to accept the invitation!
      no-invitations: You have no invitations to accept!
      invalid-invitation: The town you were invited to no longer exists.
      owner-cant-leave: You are the owner of this town! You can't leave it. use <def[command]> disband instead.
      player-not-in-your-town: <def[playername]> is not in your town.
      must-specify-townname: You must specify a name for your town!
      not-enough-money: Your town does not have enough money in the bank.
      not-enough-money-player: You do not have this much money.
      max-chunks: Your town is already at the size limit of <def[max]> chunks.
      max-outposts: Your town cannot have any more outposts.
      chunk-already-claimed-by-you: This chunk already belongs to your town.
      chunk-already-claimed-by-other: This chunk is already occupied!
      chunk-not-attached: You can only claim land surrounding your town.
      has-no-chunks: Your town does not have any chunks.
      chunk-not-yours: Your chunk does not belong to your town.
      chunk-is-essential: You cannot unclaim this chunk because the surrounding chunks in this area are not connected to any other outpost or center chunk.
      must-specify-valid-number: You must specify a valid amount!
      withdrew-money: You withdrew <def[number]> from the town bank.
      invalid-rule: You must specify a valid rule! Valid rules are <def[rulelist]>
      invalid-rank: You must specify a valid rank! Valid ranks are <def[ranklist]>
      outline-enabled: You will now see the outline of chunks when entering them.
      outline-disabled: You will no longer see the outline of chunks when entering them.
      invalid-center-chunk: You can only set your town center within your town boundaries.
      invalid-spawnpoint-location: You can only set a spawnpoint within your town boundaries.
      invalid-type-for-spawnpoint: You can only set a spawnpoint for a town or outpost! Not for <def[type]>!
      invalid-type-for-center: You can't set your town center on a <def[type]> chunk!
      not-outpost-chunk: This is not an outpost chunk!
      spawnpoint-updated: Your town spawnpoint has been updated.
      # executable messages
      town-created: <def[playername]> created the town of <def[townname]>!
      town-disbanded: The town of <def[townname]> has fallen to ruins!
      player-joined-town: <def[playername]> joined your town!
      player-joined-town-personal: You joined the town of <def[townname]>!
      player-left-town: <def[playername]> left your town!
      player-left-town-personal: You left the town of <def[townname]>!
      player-kicked: <def[playername]> was kicked from your town!
      player-kicked-personal: You were kicked from the town of <def[townname]>!
      town-renamed: Your town has been renamed to <def[townname]>
      bonus-chunks: Your town has been awarded <def[amount]> bonus chunks.
      bonus-outpost: Your town has been awarded <def[amount]> bonus outposts.
      deposit-money: <def[playername]> deposited $<def[amount]> in the town bank.
      bonus-money: Your town has been awarded $<def[amount]>!
      chunk_claim: <def[playername]> claimed a chunk of land!
      chunk-reward-claim: Your town has been given a chunk of land!
      chunk_unclaim: <def[playername]> unclaimed a chunk of land!
      chunk-reward-unclaim: Your town has lost a chunk of land!
      rule-change: <def[player].name> changed the <def[rule]> rule to <def[state]>.
      forced-rule-change: The <def[rule]> rule in your town was set to <def[state]>.
      rank-change: <def[playername]> has been assigned the <def[rank]> rank.
    spanish:
      # command help
      command-help-info: Muestra esta p<&chr[00E1]>gina.
      command-info-info: Muestra informaci<&chr[00F3]>n sobre tu ciudad.
      command-list-info: Muestra una lista de las ciudades existentes.
      command-create-info: Crea una nueva ciudad.
      command-teleport-info: Abre el men<&chr[00FA]> de teletransporte.
      command-setspawn-info: Administra puntos de aparici<&chr[00F3]>n en tu ciudad.
      command-center-info: Fija el chunk central de tu ciudad.
      command-teleport-info: Te permite teletransportarte a varios lugares.
      command-invite-info: Invita a un jugador a tu ciudad.
      command-accept-info: Acepta tu invitaci<&chr[00F3]>n pendiente.
      command-leave-info: Te elimina de tu ciudad actual.
      command-kick-info: Expulsa a un jugador de tu ciudad.
      command-deposit-info: Deposita dinero en tu ciudad.
      command-withdraw-info: Extrae dinero de tu ciudad.
      command-toggle-info: Cambia una regla determinada de tu ciudad.
      command-rank-info: Cambia el rango de un jugador.
      command-claim-info: Reclama el chunk en el que te encuentras.
      command-outpost-info: Reclama un puesto avanzado en tu posici<&chr[00F3]>n.
      command-unclaim-info: Libera el chunk en el que te encuentras.
      command-disband-info: Disuelve tu ciudad.
      command-rename-info: Cambia el nombre de tu ciudad.
      command-map-info: Muestra un mapa de tu zona actual.
      command-outline-info: Muestra los bordes del chunk de una ciudad.
      # command response
      already-in-town: <&chr[00A1]>Ya est<&chr[00E1]>s en una ciudad!
      not-enough-money-to-create: No tienes suficiente dinero para crear una ciudad. Necesitas $<def[cost]>.
      not-allowed-create: No tienes permiso para crear una ciudad.
      no-name-specified: <&chr[00A1]>Debes especificar un nombre para tu ciudad!
      not-in-town: <&chr[00A1]>No est<&chr[00E1]>s en ninguna ciudad!
      player-not-in-town: <&chr[00A1]>Este jugador no est<&chr[00E1]> en ninguna ciudad!
      not-owner-of-town: No eres el due<&chr[00F1]>o de esta ciudad.
      insufficient-rank: No tienes el rango adecuado para hacer esto.
      invalid-player-specified: <&chr[00A1]>Este jugador no est<&chr[00E1]> conectado!
      inexistant-player-specified: <&chr[00A1]>Este jugador no existe!
      target-player-already-in-town: <&chr[00A1]><def[playername]> ya est<&chr[00E1]> en una ciudad!
      invited-player: Has invitado a <def[playername]> a tu ciudad.
      invitation-recieved: <&chr[00A1]><def[playername]> te ha invitado a la ciudad de <def[townname]>!<&nl><&chr[00A1]>Escribe '<def[command]> accept' para aceptar la invitaci<&chr[00F3]>n!
      no-invitations: <&chr[00A1]>No tienes invitaciones que aceptar!
      invalid-invitation: La ciudad a la que has sido invitado ya no existe.
      owner-cant-leave: <&chr[00A1]>Eres el due<&chr[00F1]>o de esta ciudad! No puedes abandonarla. En vez de esto, utiliza '<def[command]> disband'.
      player-not-in-your-town: <def[playername]> no est<&chr[00E1]> en tu ciudad.
      must-specify-townname: <&chr[00A1]>Debes especificar un nombre para tu ciudad!
      not-enough-money: Tu ciudad no tiene suficiente dinero en el banco.
      not-enough-money-player: No tienes tanto dinero.
      max-chunks: Tu ciudad ya se encuentra al l<&chr[00ED]>mite de tama<&chr[00F1]>o de <def[max]> chunks.
      max-outposts: Tu ciudad no puede tener m<&chr[00E1]>s puestos avanzados.
      chunk-already-claimed-by-you: Este chunk ya pertenece a tu ciudad.
      chunk-already-claimed-by-other: <&chr[00A1]>Este chunk ya est<&chr[00E1]> ocupado!
      chunk-not-attached: S<&chr[00F3]>lo puedes reclamar tierra que rodee a tu ciudad.
      has-no-chunks: Tu ciudad no tiene ning<&chr[00FA]>n chunk.
      chunk-not-yours: Este chunk no pertenece a tu ciudad.
      chunk-is-essential: No puedes liberar este chunk porque los chunks circundantes no est<&chr[00E1]>n conectados a ning<&chr[00FA]>n otro puesto avanzado o chunk central.
      must-specify-valid-number: <&chr[00A1]>Debes espedificar una cantidad v<&chr[00E1]>lida!
      withdrew-money: Has extra<&chr[00ED]>do <def[number]> del banco de la ciudad.
      invalid-rule: <&chr[00A1]>Debes especificar una regla v<&chr[00E1]>lida! Las reglas v<&chr[00E1]>lidas son <def[rulelist]>
      invalid-rank: <&chr[00A1]>Debes especificar un rango v<&chr[00E1]>lido! Los rangos v<&chr[00E1]>lidos son <def[ranklist]>
      outline-enabled: Ahora ver<&chr[00E1]>s el borde de los chunks cuando entres en ellos.
      outline-disabled: Ya no ver<&chr[00E1]>s el borde de los chunks cuando entres en ellos.
      invalid-center-chunk: S<&chr[00F3]>lo puedes fijar el centro de tu ciudad dentro de los l<&chr[00ED]>mites de tu ciudad.
      invalid-spawnpoint-location: S<&chr[00F3]>lo puedes fijar un punto de aparici<&chr[00F3]>n dentro de los l<&chr[00ED]>mites de tu ciudad.
      invalid-type-for-spawnpoint: <&chr[00A1]>S<&chr[00F3]>lo puedes fijar un punto de aparici<&chr[00F3]>n para una ciudad o puesto avanzado! <&chr[00A1]>No para <def[type]>!
      invalid-type-for-center: <&chr[00A1]>No puedes fijar el centro de tu ciudad en un chunk <def[type]>!
      not-outpost-chunk: <&chr[00A1]><&chr[00C9]>ste no es un chunk de puesto avanzado!
      spawnpoint-updated: El punto de aparici<&chr[00F3]>n de tu ciudad ha sido actualizado.
      # executable messages
      town-created: <&chr[00A1]><def[playername]> cre<&chr[00F3]> la ciudad de <def[townname]>!
      town-disbanded: <&chr[00A1]>La ciudad de <def[name]> se ha arruinado!
      player-joined-town: <&chr[00A1]><def[playername]> se ha unido a tu ciudad!
      player-joined-town-personal: <&chr[00A1]>Te has unido a la ciudad de <def[townname]>!
      player-left-town: <&chr[00A1]><def[playername]> abandon<&chr[00F3]> tu ciudad!
      player-left-town-personal: <&chr[00A1]>Has abandonado la ciudad de <def[townname]>!
      player-kicked: <&chr[00A1]><def[playername]> fue expulsado de tu ciudad!
      player-kicked-personal: <&chr[00A1]>Has sido expulsado de la ciudad de <def[townname]>!
      town-renamed: Tu ciudad ha sido renombrada a <def[townname]>
      bonus-chunks: Tu ciudad ha sido recompensada con <def[amount]> chunks de bonificaci<&chr[00F3]>n.
      bonus-outpost: Tu ciudad ha sido recompensada con <def[amount]> puestos avanzados de bonificaci<&chr[00F3]>n.
      deposit-money: <def[playername]> deposit<&chr[00F3]> $<def[amount]> en el banco de la ciudad.
      bonus-money: <&chr[00A1]>Tu cuidad ha sido recompensada con $<def[amount]>!
      chunk_claim: <&chr[00A1]><def[playername]> reclam<&chr[00F3]> un chunk de tierra!
      chunk-reward-claim: <&chr[00A1]>Tu ciudad ha recibido un chunk de tierra!
      chunk_unclaim: <&chr[00A1]><def[playername]> liber<&chr[00F3]> un chunk de tierra!
      chunk-reward-unclaim: <&chr[00A1]>Tu ciudad ha perdido un chunk de tierra!
      rule-change: <def[player].name> cambi<&chr[00F3]> la regla <def[rule]> a <def[state]>.
      forced-rule-change: La regla <def[rule]> en tu ciudad fue fijada a <def[state]>.
      rank-change: <def[playername]> ha sido asignado el rango <def[rank]>.
    french:
      # command help
      command-help-info: Affiche cette page.
      command-info-info: Affiche des information sur votre ville.
      command-list-info: Affiche une liste de villes existantes.
      command-create-info: Cr<&chr[00E9]>e une nouvelle ville.
      command-teleport-info: Ouvre le menu de t<&chr[00E9]>l<&chr[00E9]>portation.
      command-setspawn-info: G<&chr[00E8]>re les points de spawn dans votre ville.
      command-center-info: Fixe le chunk central de votre ville.
      command-teleport-info: Vous permet de vous t<&chr[00E9]>l<&chr[00E9]>porter <&chr[00E0]> divers endroits.
      command-invite-info: Invite un joueur <&chr[00E0]> votre ville.
      command-accept-info: Accepte votre invitation en attente.
      command-leave-info: Vous retire de votre ville actuelle.
      command-kick-info: Expulse un joueur de votre ville.
      command-deposit-info: D<&chr[00E9]>pose de l'argent dans votre ville.
      command-withdraw-info: Pr<&chr[00E9]>leve de l'argent de votre ville.
      command-toggle-info: Bascule une certaine r<&chr[00E8]>gle dans votre ville.
      command-rank-info: Change un grade d'un joueur.
      command-claim-info: Annexe le chunk ou vous vous tenez.
      command-outpost-info: Annexe un avant-poste <&chr[00E0]> votre location.
      command-unclaim-info: Desanexxe le chunk ou vous vous tenez.
      command-disband-info: Dissoud votre ville.
      command-rename-info: Change le nom de votre ville.
      command-map-info: Montre une carte de votre zone actuelle.
      command-outline-info: Montre le contour d'un chunk de ville.
      # command response
      already-in-town: Vous faite d<&chr[00E9]>j<&chr[00E0]> partit d'une ville!
      not-enough-money-to-create: Vous n'avez pas assez d'argent pour cr<&chr[00E9]>er une ville. Vous devez avoir $<def[cost]>.
      not-allowed-create: Vous n'tes pas autoris<&chr[00E9]> <&chr[00E0]> cr<&chr[00E9]>er une ville.
      no-name-specified: Vous devez sp<&chr[00E9]>cifier un nom pour votre ville!
      not-in-town: Vous n'tes pas dans une ville!
      player-not-in-town: Ce joueur n'est pas dans une ville!
      not-owner-of-town: Vous n'tes pas le propri<&chr[00E9]>taire de cette ville.
      insufficient-rank: Vous n'avez pas le bon rang pour faire cela.
      invalid-player-specified: Ce joueur n'est pas en ligne!
      inexistant-player-specified: Ce joueur n'existe pas!
      target-player-already-in-town: <def[playername]> est d<&chr[00E9]>ja dans une ville!
      invited-player: Vous avez invit<&chr[00E9]> <def[playername]> <&chr[00E0]> votre ville.
      invitation-recieved: <def[playername]> vous a invit<&chr[00E9]> <&chr[00E0]> rejoindre la ville de <def[townname]>!<&nl>Tapez '<def[command]> accept' pour accepter l'invitation!
      no-invitations: Vous n'avez aucune invitation <&chr[00E0]> accepter!
      invalid-invitation: La ville ou vous avez <&chr[00E9]>t<&chr[00E9]> invit<&chr[00E9]> n'existe plus.
      owner-cant-leave: Vous tes le propri<&chr[00E9]>taire de cette ville! Vous ne pouvez pas la quitterY. Utilisez <def[command]> disband <&chr[00E0]> la place.
      player-not-in-your-town: <def[playername]> n'est pas dans votre ville.
      must-specify-townname: Vous devez sp<&chr[00E9]>cifier un nom pour votre ville!
      not-enough-money: Votre ville n'a pas assez d'argent dans la banque.
      not-enough-money-player: Vous n'avez pas autant cette somme.
      max-chunks: Votre ville est d<&chr[00E9]>j<&chr[00E0]> <&chr[00E0]> sa taille limite de <def[max]> chunks.
      max-outposts: Votre ville ne peut pas avoir d'avants-poste suppl<&chr[00E9]>mentaires.
      chunk-already-claimed-by-you: Ce chunk appartient d<&chr[00E9]>ja <&chr[00E0]> votre ville.
      chunk-already-claimed-by-other: Ce chunk est d<&chr[00E9]>j<&chr[00E0]> occup<&chr[00E9]>!
      chunk-not-attached: Vous ne pouvez annexer seulement le terrain autour de votre ville.
      has-no-chunks: Votre ville n'a pas de chunk.
      chunk-not-yours: Votre chunk n'appartient pas <&chr[00E0]> votre ville.
      chunk-is-essential: Vous ne pouvez pas desannexer ce chunk car les chunk autour de cette zone ne sont pas connect<&chr[00E9]> <&chr[00E0]> aucun avant-poste ou chunk central.
      must-specify-valid-number: Vous devez sp<&chr[00E9]>cifier un montant valide!
      withdrew-money: Vous avez pr<&chr[00E9]>lev<&chr[00E9]> <def[number]> de la banque de ville.
      invalid-rule: Vous devez sp<&chr[00E9]>cifier une r<&chr[00E8]>gle valide! Les r<&chr[00E8]>gles valide sont <def[rulelist]>
      invalid-rank: Vous devez sp<&chr[00E9]>cifier un rang valide! Les rangs valide sont <def[ranklist]>
      outline-enabled: Vous allez maintenant voir le contour des chunk lorsque vous entrez sur eux.
      outline-disabled: Vous n'allez plus voir le contor des chunk lorsque vous entrez sur eux.
      invalid-center-chunk: Vous pouvez seulement fixer le point central de votre ville dans les limites de votre ville.
      invalid-spawnpoint-location: Vous pouvez seulement fixer un point de spawn dans les limites de votre ville.
      invalid-type-for-spawnpoint: Vous pouvez seulement fixer un point de spawn pour votre ville ou vos avant-poste! Pas pour <def[type]>!
      invalid-type-for-center: Vous ne pouvez pas fixer le centre de votre ville sur un chunk <def[type]>!
      not-outpost-chunk: Cela n'est pas un chunk avant-poste!
      spawnpoint-updated: Votre point de spawn a <&chr[00E9]>t<&chr[00E9]> mis <&chr[00E0]> jour.
      # executable messages
      town-created: <def[playername]> a cr<&chr[00E9]>e la ville de <def[townname]>!
      town-disbanded: La ville de <def[townname]> est tomb<&chr[00E9]> en ruine!
      player-joined-town: <def[playername]> a rejoint votre ville!
      player-joined-town-personal: Vous avez rejoint la ville de <def[townname]>!
      player-left-town: <def[playername]> a quitt<&chr[00E9]> votre ville!
      player-left-town-personal: Vous avez quitt<&chr[00E9]> la ville de <def[townname]>!
      player-kicked: <def[playername]> a <&chr[00E9]>t<&chr[00E9]> expuls<&chr[00E9]> de votre ville!
      player-kicked-personal: Vous avez <&chr[00E9]>t<&chr[00E9]> expuls<&chr[00E9]> de la ville de <def[townname]>!
      town-renamed: Votre ville a <&chr[00E9]>t<&chr[00E9]> renomm<&chr[00E9]> en <def[townname]>
      bonus-chunks: Il a <&chr[00E9]>t<&chr[00E9]> attribu<&chr[00E9]> <&chr[00E0]> votre ville <def[amount]> chunks bonus.
      bonus-outpost: Il a <&chr[00E9]>t<&chr[00E9]> attribu<&chr[00E9]> <&chr[00E0]> votre ville <def[amount]> avant-poste bonus.
      deposit-money: <def[playername]> <&chr[00E0]> d<&chr[00E9]>pos<&chr[00E9]> $<def[amount]> dans la banque de la ville.
      bonus-money: Il a <&chr[00E9]>t<&chr[00E9]> attribu<&chr[00E9]> <&chr[00E0]> votre ville $<def[amount]>!
      chunk_claim: <def[playername]> a annex<&chr[00E9]> un chunk de terrain!
      chunk-reward-claim: Il vous a <&chr[00E9]>t<&chr[00E9]> attribu<&chr[00E9]> <&chr[00E0]> votre ville un chunk de terrain!
      chunk_unclaim: <def[playername]> a d<&chr[00E9]>sannex<&chr[00E9]> un chunk de terrain!
      chunk-reward-unclaim: Votre ville a perdu un chunk de terrain!
      rule-change: <def[player].name> a chang<&chr[00E9]> la r<&chr[00E8]>gle <def[rule]> <&chr[00E0]> <def[state]>.
      forced-rule-change: La r<&chr[00E8]>gle <def[rule]> dans votre ville a <&chr[00E9]>t<&chr[00E9]> fix<&chr[00E9]> <&chr[00E0]> <def[state]>.
      rank-change: <def[playername]> a <&chr[00E9]>t<&chr[00E9]> assign<&chr[00E9]> le rang de <def[rank]>.
########################
#
# tags
#
######################
towns_get_town:
  type: procedure
  debug: false
  definitions: player
  script:
  - if <def[player]||null> == null {
    - define player <player||null>
    - if <def[player]> == null determine null
    }
  - determine <yaml[towns_lookup_table].read[players.<def[player].uuid>.town]||null>
towns_get_name:
  type: procedure
  debug: false
  definitions: town
  script:
  - if <def[town]||null> == null determine null
  - inject s@towns_checkload_town
  - determine <yaml[towns_town_<def[town]>].read[town.name].unescaped||li@>
towns_get_rank:
  type: procedure
  debug: false
  definitions: player
  script:
  - if <def[player]||null> == null {
    - define player <player>
    }
  - define town <proc[towns_get_town].context[<def[player]>]>
  - determine <yaml[towns_town_<def[town]>].read[town.members.<def[player].uuid>.rank]||null>
towns_get_members:
  type: procedure
  debug: false
  definitions: town
  script:
  - if <def[town]||null> == null determine null
  - determine <yaml[towns_town_<def[town]>].list_keys[town.members].parse[as_player]||li@>
towns_get_members_by_rank:
  type: procedure
  debug: false
  definitions: town|rank
  script:
  - if <def[town]||null> == null determine null
  - if <def[rank]||null> == null determine null
  - define list li@
  - foreach <yaml[towns_town_<def[town]>].list_keys[town.members]||li@>:
    - if <proc[towns_get_rank].context[<def[value].as_player>]> == <def[rank]> {
      - define list <def[list].include[<def[value]>]>
      }
  - determine <def[list].parse[as_player]||li@>
towns_get_bank_money:
  type: procedure
  debug: false
  definitions: town
  script:
  - if <def[town]||null> == null determine null
  - determine <yaml[towns_town_<def[town]>].read[town.bank.money]||0>
towns_get_chunks:
  type: procedure
  debug: false
  definitions: town
  script:
  - if <def[town]||null> == null determine null
  - inject s@towns_checkload_town
  - determine <yaml[towns_town_<def[town]>].list_keys[town.chunks]||li@>
towns_get_chunk_type:
  type: procedure
  debug: false
  definitions: chunk
  script:
  - if <def[chunk]||null> == null determine null
  - define town <proc[towns_get_town_from_chunk].context[<def[chunk]>]||null>
  - determine <yaml[towns_town_<def[town]>].read[town.chunks.<proc[towns_format_chunk_to_save].context[<def[chunk]>]>.type]||null>
towns_get_outposts:
  type: procedure
  debug: false
  definitions: town
  script:
  - if <def[town]||null> == null determine null
  - define outposts li@
  - foreach <yaml[towns_town_<def[town]>].list_keys[town.chunks]||li@>:
    - if <yaml[towns_town_<def[town]>].read[town.chunks.<def[value]>.type]||normal> == outpost {
      - define outposts <def[outposts].include[<def[value]>]>
      }
  - determine <def[outposts]||li@>
towns_get_town_from_chunk:
  type: procedure
  debug: false
  definitions: chunk
  script:
  - if <def[chunk]||null> == null determine null
  - determine <yaml[towns_lookup_table].read[chunks.<def[chunk].world.name>.<def[chunk].x>.<def[chunk].z>]||null>
towns_get_outpost_spawnpoint:
  type: procedure
  debug: false
  definitions: chunk
  script:
  - if <def[chunk]||null> == null determine null
  - define town <proc[towns_get_town_from_chunk].context[<def[chunk]>]||null>
  - if <def[town]> == null determine null
  - define spawnpoint <yaml[towns_town_<def[town]>].read[town.chunks.<proc[towns_format_chunk_to_save].context[<def[chunk]>]>.spawnpoint].unescaped||null>
  - if <def[spawnpoint]> == null {
    - define center <def[chunk].cuboid.center||null>
    - define center <def[center].x>,<def[chunk].average_height>,<def[center].z>,<def[center].world.name>
    - define spawnpoint <def[center].as_location.find.surface_blocks.within[16].get[1].above||null>
    }
  - determine <def[spawnpoint].center||null>
towns_get_max_chunks:
  type: procedure
  debug: false
  definitions: town
  script:
  - if <def[town]||null> == null determine null
  - determine <proc[towns_get_members].context[<def[town]>].size.mul[<yaml[towns_config].read[towns.claiming.chunks_per_player]||8>].add[<yaml[towns_town_<def[town]>].read[town.bonus_chunks].as_int||0>].as_int||0>
towns_get_max_outposts:
  type: procedure
  debug: false
  definitions: town
  script:
  - if <def[town]||null> == null determine null
  - determine <proc[towns_get_members].context[<def[town]>].size.mul[<yaml[towns_config].read[towns.claiming.outposts_per_player]||1>].add[<yaml[towns_town_<def[town]>].read[town.bonus_outposts].as_int||0>].as_int||0>
towns_format_chunk_to_save:
  type: procedure
  debug: false
  definitions: chunk
  script:
  - if <def[chunk]||null> == null determine null
  - determine "<def[chunk].x>/<def[chunk].z>/<def[chunk].world.name.escaped>"
towns_format_chunk_to_normal:
  type: procedure
  debug: false
  definitions: chunk
  script:
  - if <def[chunk]||null> == null determine null
  - define chunk <def[chunk].split_by[/].get[1]||null>,<def[chunk].split_by[/].get[2]||null>,<def[chunk].split_by[/].get[3].unescaped||null>
  - determine "<def[chunk].as_chunk>"
towns_get_rule:
  type: procedure
  debug: false
  definitions: town|rule
  script:
  - if <def[town]||null> == null determine null
  - if <def[rule]||null> == null determine null
  - inject s@towns_checkload_town
  - determine <yaml[towns_town_<def[town]>].read[town.rule.<def[rule]>]||true>
towns_get_spawnpoint:
  type: procedure
  debug: false
  definitions: town
  script:
  - if <def[town]||null> == null determine null
  - define spawnpoint <yaml[towns_town_<def[town]>].read[town.spawnpoint].unescaped||null>
  - if <def[spawnpoint]> == null {
    - define chunk <yaml[towns_town_<def[town]>].read[town.center].replace[/].with[,].as_chunk||null>
    - define center <def[chunk].cuboid.center||null>
    - if <def[center]> == null determine null
    - define center <def[center].x>,<def[chunk].average_height>,<def[center].z>,<def[center].world.name>
    - define spawnpoint <def[center].as_location.find.surface_blocks.within[5].get[1].above||null>
    }
  - determine <def[spawnpoint].center||null>
towns_get_groupuuid_for_new_chunk:
  type: procedure
  debug: false
  definitions: town|chunk
  script:
  - if <def[chunk]||null> == null determine null
  - if <def[town]||null> == null determine null
  - foreach li@<def[chunk].add[1,0]>|<def[chunk].add[-1,0]>|<def[chunk].add[0,1]>|<def[chunk].add[0,-1]>:
    - if <proc[towns_get_town_from_chunk].context[<def[value]>]> == <def[town]> {
      - define UUID <proc[towns_get_groupuuid_from_chunk].context[<def[value]>]>
      }
  - if <def[uuid].exists.not> {
    - define uuid <util.random.uuid>
    }
  - determine <def[uuid]>
towns_get_groupuuid_from_chunk:
  type: procedure
  debug: false
  definitions: chunk
  script:
  - if <def[chunk]||null> == null determine null
  - define town <proc[towns_get_town_from_chunk].context[<def[chunk]>]>
  - define uuid <yaml[towns_town_<def[town]>].read[town.chunks.<proc[towns_format_chunk_to_save].context[<def[chunk]>]>.group]||null>
  - determine <def[uuid]>
towns_get_chunks_by_groupuuid:
  type: procedure
  debug: false
  definitions: town|uuid
  script:
  - if <def[uuid]||null> == null determine null
  - if <def[town]||null> == null determine null
  - define chunks li@
  - foreach <proc[towns_get_chunks].context[<def[town]>].parse[replace[/].with[,].as_chunk]>:
    - if <proc[towns_get_groupuuid_from_chunk].context[<def[value]>]> == <def[uuid]> {
      - define chunks <def[chunks].include[<def[value]>]>
      }
  - determine <def[chunks]>
towns_chunk_is_essential:
  type: procedure
  debug: false
  definitions: chunk
  script:
  - if <def[chunk]||null> == null determine null
  - define town <proc[towns_get_town_from_chunk].context[<def[chunk]>]>
  - if <def[town]> == null determine false
  - define type <proc[towns_get_chunk_type].context[<def[chunk]>]>
  - if li@center|outpost !contains <def[type]> determine false
  - define uuid <proc[towns_get_groupuuid_from_chunk].context[<def[chunk]>]>
  - define group <proc[towns_get_chunks_by_groupuuid].context[<def[town]>|<def[uuid]>].exclude[<def[chunk]>]>
  - if <def[group].size> < 1 determine false
  - foreach <def[group]>:
    - if li@center|outpost contains <proc[towns_get_chunk_type].context[<def[chunk]>]> {
      - determine false
      }
  - foreach <def[group]>:
    - define currentchunk <def[value]>
    - foreach li@<def[currentchunk].add[1,0]>|<def[currentchunk].add[-1,0]>|<def[currentchunk].add[0,1]>|<def[currentchunk].add[0,-1]>:
      - define currentuuid <proc[towns_get_groupuuid_from_chunk].context[<def[value]>]>
      - if <def[currentuuid]> != <def[uuid]> && <def[currentuuid]> != null {
        - determine false
        }
  - determine true
########################
#
# towns menus
#
######################
towns_teleport_menu:
  type: inventory
  inventory: chest
  title: <&6>Town Teleport Menu
  size: 54
  procedural items:
  - define town <player.flag[towns.town_inv]||<proc[towns_get_town]>>
  - define items li@
  - define spawnpoint <proc[towns_get_spawnpoint].context[<def[town]>]>
  - if <def[spawnpoint]> != null {
    - define items "<def[items].include[i@nether_star[display_name=<&6>Town Spawnpoint;nbt=li@location/<def[spawnpoint]>]]>"
    }
  - foreach <proc[towns_get_outposts].context[<def[town]>].parse[replace[/].with[,].as_chunk]||li@>:
    - define spawnpoint <proc[towns_get_outpost_spawnpoint].context[<def[value]>]||null>
    - if <def[spawnpoint]> != null {
      - define items "<def[items].include[i@sign[display_name=<&6>Outpost <def[loop_index]> Spawnpoint;lore=li@<&7>Location<&co> X <def[spawnpoint].x.as_int> Z <def[spawnpoint].z.as_int> in <def[spawnpoint].world.name>;nbt=li@location/<def[spawnpoint]>]]>"
      }
  - determine <def[items]>
  slots:
    - "[] [] [] [] [] [] [] [] []"
towns_teleport_menu_events:
  type: world
  debug: false
  events:
    on player clicks in towns_teleport_menu:
    - determine cancelled passively
    - define location <context.item.nbt[location]||null>
    - if <def[location]> == null queue clear
    - inventory close
    - playsound ENTITY_ENDERMEN_TELEPORT <player.location>
    - playeffect effect:PORTAL data:0.4 qty:500 offset:0.1 <player.location>
    - teleport <def[location].add[0,0.5,0]>
    - playsound ENTITY_ENDERMEN_TELEPORT <player.location>
    - playeffect effect:PORTAL data:0.4 qty:500 offset:0.1 <player.location>
########################
#
# chat format
#
######################
towns_format1:
  type: format
  format: <&8>[<&6>Towns<&8>] <&e><text>
########################
#
# town item claim rewards
#
######################
town_chunk_claim_token:
  type: item
  material: i@gold_record[flags=li@hide_enchants]
  display name: <&6>Town Chunk Token
  enchantments: 
  - durability:1
  lore:
  - <&7>A town chunk token.
  - <&7>Used to gain bonus chunks for a town.
town_outpost_claim_token:
  type: item
  material: i@gold_record[flags=li@hide_enchants]
  display name: <&6>Town Outpost Token
  enchantments: 
  - durability:1
  lore:
  - <&7>A town outpost token.
  - <&7>Used to gain bonus outposts for a town.
town_chunk_claim_token_events:
  type: world
  debug: false
  events:
    on player right clicks with town_chunk_claim_token:
    - determine cancelled passively
    - if <proc[towns_get_town]> == null {
      - narrate "<&c>You are not in a town!" format:towns_format1
      - queue clear
      }
    - take i@town_chunk_claim_token
    - run towns_add_bonus_chunks def:<proc[towns_get_town]>|1
    - flag server towns.claimed_bonuses.chunks.<player>:++
    on player right clicks with town_outpost_claim_token:
    - determine cancelled passively
    - if <proc[towns_get_town]> == null {
      - narrate "<&c>You are not in a town!" format:towns_format1
      - queue clear
      }
    - take i@town_outpost_claim_token
    - run towns_add_bonus_outposts def:<proc[towns_get_town]>|1
    - flag server towns.claimed_bonuses.outposts.<player>:++
########################
#
# dynmap bridge
#
######################
towns_update_dynmap_chunk:
  type: task
  debug: false
  speed: 0
  definitions: chunk
  script:
      - if <def[chunk]||null> == null queue clear
      - if <yaml[towns_config].read[towns.use_dynmap].not||true> queue clear
      - define chunkname <proc[towns_format_chunk_to_save].context[<def[chunk]>]>
      - execute as_server "dmarker deletearea id:<def[chunkname]>"
      - define town <proc[towns_get_town_from_chunk].context[<def[chunk]>]>
      - if <def[town]> == null queue clear
      - define cuboid <def[chunk].cuboid>
      - define world <def[cuboid].max.world.name>
      - define name <proc[towns_get_name].context[<def[town]>]>
      - choose <proc[towns_get_chunk_type].context[<def[chunk]>]>:
        - case center:
          - define color F5F542
        - case outpost:
          - define color 05FF26
        - default:
          - define color 21B9DB
      - define locs li@<def[cuboid].min.x.sub[0.5]>/<def[cuboid].min.z.sub[0.5]>|<def[cuboid].max.x.add[0.5]>/<def[cuboid].min.z.sub[0.5]>|<def[cuboid].max.x.add[0.5]>/<def[cuboid].max.z.add[0.5]>|<def[cuboid].min.x.sub[0.5]>/<def[cuboid].max.z.add[0.5]>
      - execute as_server "dmarker clearcorners"
      - foreach <def[locs]>:
        - execute as_server "dmarker addcorner <def[value].before[/]> 0 <def[value].after[/]> <def[world]>"
      - execute as_server "dmarker addarea id:<def[chunkname]> <&dq>Town - <def[name]><&dq>"
      - execute as_server "dmarker updatearea id:<def[chunkname]> fillcolor:<def[color]> color:52C2F2 opacity:0.0 fillopacity:0.3"
towns_update_dynmap_spawnpoint:
  type: task
  debug: false
  speed: 0
  definitions: town
  script:
  - if <def[town]||null> == null queue clear
  - if <yaml[towns_config].read[towns.use_dynmap].not||true> queue clear
  - define spawnpoint <proc[towns_get_spawnpoint].context[<def[town]>]>
  - if <def[spawnpoint]> == null queue clear
  - execute as_server "dmarker delete id:<def[town]>/spawnpoint"
  - execute as_server "dmarker add id:<def[town]>/spawnpoint <&dq>Town - <proc[towns_get_name].context[<def[town]>]><&dq> icon:sign x:<def[spawnpoint].x> y:<def[spawnpoint].y> z:<def[spawnpoint].z> world:<def[spawnpoint].world.name>"
towns_update_dynmap_town:
  type: task
  debug: false
  speed: 0
  definitions: town
  script:
    - if <def[town]||null> == null queue clear
    - if <yaml[towns_config].read[towns.use_dynmap].not||true> queue clear
    - run towns_update_dynmap_spawnpoint def:<def[town]>
    - foreach <proc[towns_get_chunks].context[<def[town]>].parse[replace[/].with[,].as_chunk]>:
      - ~run towns_update_dynmap_chunk def:<def[value]>
towns_update_dynmap_all_towns:
  type: task
  debug: false
  speed: 0
  script:
    - if <yaml[towns_config].read[towns.use_dynmap].not||true> queue clear
    - foreach <yaml[towns_lookup_table].list_keys[towns]||li@>:
      - run towns_update_dynmap_town def:<def[value]>
towns_dynmap_clear_areas:
  type: task
  debug: false
  speed: 0
  script:
    - if <yaml[towns_config].read[towns.use_dynmap].not||true> queue clear
    - execute as_server "dmarker listareas" save:areas
    - foreach <entry[areas].output>:
      - execute as_server "dmarker deletearea id:<def[value].before[<&co>]>"
    - execute as_server "dmarker list" save:blah
    - foreach "<entry[blah].output>":
      - execute as_server "dmarker delete id:<def[value].before[<&co>]>"
towns_dynmap_shutdown_handler:
  type: world
  debug: false
  events:
    on shutdown:
    - if <yaml[towns_config].read[towns.allow_dynmap_shenanigans].not||true> queue clear
    - if <server.has_file[../dynmap/markers.yml]> {
      - adjust server delete_file:../dynmap/markers.yml
      }
    - inject s@towns_dynmap_clear_areas
    on server prestart:
    - if <yaml[towns_config].read[towns.allow_dynmap_shenanigans].not||true> queue clear
    - if <server.has_file[../dynmap/markers.yml]> {
      - adjust server delete_file:../dynmap/markers.yml
      }
    - wait 1s
    - run towns_update_dynmap_all_towns
